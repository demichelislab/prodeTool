#' Run PRODE on pre-processed input data computin Confidence Intervals.
#'
#' @details This function applies runPRODE multiple times across increasingly 
#' reduced interactions, according to higher weights. The number of splits 
#' is defined by \code{ci_splits}. Please, see \code{runPRODE} function for 
#' more detailed explanation of a PRODE run.  
#' @param prodeInput object of class ProdeInput. This is generated by first
#'    running \code{getProdeInput} function.
#' @param scaledEst logical, whether or not consider ranks of scaled coefficients
#'    from linear model fits. If set to \code{FALSE} gene ranks are computed
#'    considering thee unscaled coefficient. Default set to \code{TRUE}.
#' @param ci_splits integer, the number of bins in which divide the edge weights. Default is 5. 
#' @param ci_level integer, the confidence level for the CI computation, default 0.95.
#' @param design this is the design formula required for NICE score computation. In the case of
#'    NIE score computation, this can be ignored (default set to \code{NULL}). \code{design} has to
#'    be a \code{formula} object. Last variable in formula will be considered as the group
#'    variable for the linear model fit, requiring 1 for case group and 0 for control group.
#' @returns for \code{results()}, it returns a data.frame with different results
#'     as columns, depending if NIE or NICE scores have been computed.
#'     \subsection{Gene-level results}{
#'         \itemize{
#'          \item{\code{Estimate}} in case of NIE scores, it corresponds to the intercept of model fit,
#'          i.e., for each gene, the average values across samples. In case of NICE scores, it's
#'          the coefficient of to the variable encoding the condition of
#'          interest, as represented in the \code{prodeInput} object.,
#'          \item{\code{Std...Error}} is the coefficient standard error, as computed by \code{summary(lm())}
#'          \item{\code{t.value}} is the Estimate rescaled by Std. Error, as computed by \code{summary(lm())}
#'          \item{\code{Pr...t..}} is the probablity associated to the t-value, as computed by \code{summary(lm())}
#'          }
#'      }
#'     \subsection{Neighborhood-level results}{
#'         \itemize{
#'              \item{\code{rra_score}} is the \eqn{\rho} value computed by RRA algorithm for each gene.
#'              \item{\code{rra_p}} is the p-value corresponding to each \eqn{\rho} value (computed according to neighborhood size).
#'              \item{\code{rra_fdr}} is the FDR computed from \code{rra_p}.
#'         }
#'     }
#'     \subsection{Final Score results}{
#'         \itemize{
#'              \item{\code{u_gene}} is the percentile of gene-level signal (\code{Estimate}
#'              or \code{t.value} columns, depeindin if \code{scaledEst=T})
#'              \item{\code{u_neigh}} is the percentile of neighborhood-level signal (\code{rra_p}).
#'              \item{\code{NIE_score}} or \code{NICE_score} computed as \eqn{log(u_{gene} \times u_{neigh})}
#'         }
#'     }
#'      \subsection{If \code{extendedNICEStats=TRUE}}{
#'           \itemize{
#'               \item{\code{ctrl_mean}} is the average value, for each gene, of control samples.
#'               \item{\code{case_mean}} is the average value, for each gene, of case samples.
#'               \item{\code{ctrl_sd}} is the standard deviation of each gene values in control samples.
#'               \item{\code{case_sd}} is the standard deviation of each gene values in case samples.
#'               \item{\code{ctrl_n}} is the number of samples in the control group.
#'               \item{\code{case_n}} is the number of samples in the case group.
#'          }
#'      }
#' @export
runProdeCI <- function(
    prodeInput,
    scaledEst=T,
    filterCtrl = F,
    ci_splits = 10, 
    ci_level = 0.95, 
    design = NULL
){
  
  idxs_etb <- .findCommonIndexes(ci_splits, prodeInput@weights, prodeInput@etab)
  
  if (prodeInput@modality=='NIE_score'){
    
    k <- 1
    runs <- lapply(idxs_etb[[2]], function(kk){
      message('Iteration number: ', k)
      k <<- k+1
      enet_loc <- prodeInput@etab[kk,]
      
      mm <- prodeInput@assays@data$score_matrix
      dd <- prodeInput@colData
      
      inPRO <- suppressMessages(getProdeInput(mm, dd, enet_loc))
      ouPRO <- suppressMessages(runProde(inPRO, scaledEst = F))
      return(ouPRO)
      
    })
  } else {
    
    if (is.null(design)){
      stop('Please provide design formula for NICE scores CI')
    }
    
    k <- 1
    runs <- lapply(idxs_etb[[2]], function(kk){
      message('Iteration number: ', k)
      k <<- k+1
      enet_loc <- prodeInput@etab[kk,]
      
      mm <- prodeInput@assays@data$score_matrix
      dd <- prodeInput@colData
      
      inPRO <- suppressMessages(getProdeInput(mm, dd, enet_loc, design))
      ouPRO <- suppressMessages(runProde(inPRO, scaledEst = scaledEst, filterCtrl = filterCtrl))
      
      return(ouPRO)
      
    })
  }
  
  gns <- Reduce(intersect, lapply(runs, function(run) results(run)$gene))
  
  tab <- do.call(cbind, 
                 
                 lapply(runs, function(run){
                   
                   res_tab <- run@results
                   res_tab <- res_tab[which(res_tab$gene %in% gns),]
                   res_tab[match(gns, res_tab$gene),grepl('E_score', colnames(res_tab))]
                   
                 })
  )
  

  cis <- t(apply(tab, 1, .getCI))
  sco <- rowMeans(tab)
  
  res <- runs[[1]]
  res@results <- .mergeResTable(results(res), gns)
  
  if (prodeInput@modality=='NIE_score'){
    res@results$NIE_score <- rowMeans(tab, na.rm=T)
    res@results$CI_lower  <- cis[,1]
    res@results$CI_upper  <- cis[,2]
  } else {
    res@results$NICE_score <- rowMeans(tab, na.rm=T)
    res@results$CI_lower  <- cis[,1]
    res@results$CI_upper  <- cis[,2]
  }
  
  return(res)
  
}

